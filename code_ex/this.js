// более подробно можно ознакомиться по ссылке 
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

console.log(this.document === document); // true

console.log(this === window); // true
// В браузерах, объект window также является глобальным:

this.a = 37;
console.log(window.a); // 37


// переопределяем контекст 
var sport = {
	tournament: 'The master',
	players: [
		{
			name: 'Bob',
			age: 32
		},
		{
			name: 'Sam',
			age: 54
		}
	],
	show: function() {
		var self = this;
		this.players.forEach(function(person) {
			console.log(person, self.tournament);
		})
	}
}

sport.show();


// В стрелочных функциях, this привязан к окружению, в котором 
// была создана функция. В глобальной области видимости, this 
// будет указывать на глобальный объект.

var globalObject = this;
var foo = (() => this);
console.log(foo() === globalObject); // true


// Не важно, как функция foo() будет вызвана, ее this будет 
// указывать на глобальный объект. this будет сохранять свое 
// значение, даже если функция foo() будет вызвана как метод 
// обьекта (что в обычных функциях связывает this с объектом 
// вызова) или с использованием методов call, apply или bind:

// Вызов функции как метода объекта
var obj = {foo: foo};
console.log(obj.foo() === globalObject); // true

// Попытка установить this с помощью call
console.log(foo.call(obj) === globalObject); // true

// Попытка установить this с помощью bind
foo = foo.bind(obj);
console.log(foo() === globalObject); // true
Независимо от этого, this функции foo() имеет тоже значение, что и при создании функции (глобальный объект в примере выше). То же самое касается стрелочных функций созданных внутри других функций: их this будет привязан к окружению.

// Создаем объект obj с методом bar который возвращает функцию
// которая возвращает свой this. Возвращаемая функция созданна
// как стрелочная функция, таким образом ее this замкнут 
// на this функции в которой она созданна. 
var obj = { bar : function() {
                    var x = (() => this);
                    return x;
                  }
          };

// Вызываем bar как метод объекта obj, устанавливая его this на obj
// Присваиваем ссылку возвращаемой функции fn
var fn = obj.bar();

// Вызываем fn без установки this, что в обычных функциях указывало бы
// на глобальный объект или undefined в строгом режиме.
console.log(fn() === obj); // true


// Необходимо отметить, что  на поведение this совсем не влияет то, 
// как или где была определена функция.  В предыдущем примере мы 
// определили функцию внутри свойства  f  во время определения 
// объекта o. Однако, мы могли бы также просто определить сначала 
// функцию, а затем закрепить ее за за свойством o.f. В этом случае 
// поведение this не изменится:

var o = {prop: 37};

function independent() {
  return this.prop;
}

o.f = independent;

console.log(o.f()); // logs 37



// Когда в теле функции используется ключевое слово this ,  его 
// значение может быть привязано к конкретному объекту в вызове 
// при помощи методов  call or apply ,которые наследуются всеми 
// функциями от Function.prototype.

function add(c, d){
  return this.a + this.b + c + d;
}

var o = {a:1, b:3};

add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
// Первый параметр - это объект, который следует использовать как
// 'this', последующие параметры передаются 
// как аргументы при вызове функции

add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
// Первый параметр - объект, который следует использовать как
// 'this', второй параметр - массив, 
// элементы которого используются как аргументы при вызове функции