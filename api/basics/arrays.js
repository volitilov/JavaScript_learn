// более подробно можно ознакомиться по ссылке 
// https://learn.javascript.ru/array
// https://learn.javascript.ru/array-methods
// https://learn.javascript.ru/array-iteration

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

var arr = new Array();
var arr = [];
// создание массива

arr = new Array(5)
// создание пустого массива из 5 ячеек

arr = ['str', 123, true, undefined, {key, 'value'}, []]
// можно хранить любые типы данных

arr[0]
// получение значения по индексу

arr[0] = 'new value'
arr.name = 'name'
// присвоение нового значения

arr.length
// получение длины массива

arr.length = 2 
// укоротить до 2 элементов

arr[4].key
// получить объект из массива и тут же -- его свойство

arr.pop()
// удаляет последний элемент из массива и возвращает его

arr.push(elem)
// добавляет элемент в конец массива

arr.shift()
// Удаляет из массива первый элемент и возвращает его

arr.unshift(elem)
// Добавляет элемент в начало массива

arr.split(s, 2)
// позволяет превратить строку в массив, разбив ее по разделителю s
// второй аргумент – ограничение на количество элементов в массиве. 
// Если их больше, чем указано – остаток массива будет отброшен

arr.split('')
// разбивка по буквам

arr.join(str) 
// делает в точности противоположное split. Он берет массив и 
// склеивает его в строку, используя str как разделитель (если он есть)

delete arr[1]
// удалить значение с индексом 1

arr.splice(index, deleteCount, elem1, elemN)
// Умеет все: удалять элементы, вставлять элементы, заменять 
// элементы – по очереди и одновременно
// Удалить deleteCount элементов, начиная с номера index, а затем вставить 
// elem1, ..., elemN на их место. Возвращает массив из удалённых элементов
// также может вставлять элементы без удаления, для этого достаточно 
// установить deleteCount в 0

arr.slice(begin, end) 
// копирует участок массива от begin до end, не включая end. 
// Исходный массив при этом не меняется

arr.sort()
// сортирует массив

arr.reverse() 
// меняет порядок элементов в массиве на обратный

var newArr = arr.concat(value1, value2, … valueN)
// создаёт новый массив, в который копируются элементы из arr, а также 
// value1, value2, ... valueN

arr.indexOf(searchElement, fromIndex)
// возвращает номер элемента searchElement в массиве arr или -1, 
// если его нет. Поиск начинается с номера fromIndex, если он указан. 
// Если нет – с начала массива.
// не поддерживаются в IE8-. Для поддержки надо подключить библиотеку 
// ES5-shim

arr.lastIndexOf(searchElement, fromIndex)
// ищет справа-налево: с конца массива или с номера fromIndex, если он 
// указан.
// не поддерживаются в IE8-. Для поддержки надо подключить библиотеку 
// ES5-shim

var mas = Object.keys(obj)
// Если мы хотим работать с ними в виде массива, то к нашим 
// услугам – замечательный метод Object.keys(obj). Он 
// поддерживается везде, кроме IE8


arr.forEach(callback(item, i, arr), thisArg)
// используется для перебора массива. Он для каждого элемента массива 
// вызывает функцию callback. Этой функции он передаёт три параметра 
// callback(item, i, arr): 
// item – очередной элемент массива, 
// i – его номер,
// arr – массив, который перебирается.
// Второй, необязательный аргумент позволяет указать контекст this 
// для callback

var newArr = arr.filter(callback(item, i, arr), thisArg)
// используется для фильтрации массива через функцию. Он создаёт 
// новый массив, в который войдут только те элементы arr, для которых 
// вызов callback(item, i, arr) возвратит true

var newArr = arr.map(callback, thisArg)
// используется для трансформации массива. Он создаёт новый массив, 
// который будет состоять из результатов вызова callback(item, i, arr) 
// для каждого элемента arr

arr.every(callback, thisArg) 
// возвращает true, если вызов callback вернёт true для каждого 
// элемента arr.

arr.some(callback, thisArg)
// возвращает true, если вызов callback вернёт true для какого-нибудь 
// элемента arr

arr.reduce(callback(previousValue, currentItem, index, arr), initialValue)
// используется для последовательной обработки каждого элемента массива 
// с сохранением промежуточного результата.
// Он применяет функцию callback по очереди к каждому элементу массива 
// слева направо, сохраняя при этом промежуточный результат.
// Аргументы функции callback(previousValue, currentItem, index, arr):
// previousValue – последний результат вызова функции, он же 
// «промежуточный результат».

// currentItem – текущий элемент массива, элементы перебираются по очереди 
// слева-направо.

// index – номер текущего элемента.

// arr – обрабатываемый массив.

// Кроме callback, методу можно передать «начальное значение» – аргумент 
// initialValue. Если он есть, то на первом вызове значение previousValue 
// будет равно initialValue, а если у reduce нет второго аргумента, то оно 
// равно первому элементу массива, а перебор начинается со второго.

arr.reduceRight(callback(previousValue, currentItem, index, arr), initialValue) 
// работает аналогично методу reduce(), но идёт по массиву справа-налево